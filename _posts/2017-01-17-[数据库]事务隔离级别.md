---
layout: post
title: '事务隔离级别'
date: 2017-01-17
author: Feihang Han
tags: 数据库
---

# 事务并发问题

当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：

* 脏读

脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

| 事务A | 事务B |
| :--- | :--- |
| 事务开始 | 事务开始 |
| 读取X=100 |  |
| 写入X=200 |  |
|  | 读取X=200 |
|  | 事务结束 |
| 事务回滚 |  |

* 不可重复读

不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

| 事务A | 事务B |
| :--- | :--- |
| 事务开始 | 事务开始 |
| 读取X=100 | 读取X=100 |
| 写入X=200 |  |
| 提交事务 |  |
|  | 读取X=200 |
|  | 事务结束 |

* 幻读

一个事务读取到另一事务已提交的insert数据。

| 事务A | 事务B |
| :--- | :--- |
| 事务开始 | 事务开始 |
|  | 读取数据集M（3行） |
| 插入一行数据到数据集M（4行） |  |
| 提交事务 |  |
|  | 读取数据集M（4行） |
|  | 事务结束 |

---

# 锁

* 共享锁（S锁）又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在事务T释放A上的S锁之前不能对A做任何修改。

* 排他锁（X锁）又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

# 事务隔离级别

| 该级别是否有右侧的问题 | 脏读 | 不可重复读 | 幻读 |
| :--- | :---: | :---: | :---: |
| Read uncommitted | yes | yes | yes |
| Read committed | no | yes | yes |
| Repeatable read | no | no | yes |
| Serializable | no | no | no |

# 原理及分析

# Read uncommitted

原理

```
事务在读数据的时候并未对数据加锁；

事务在修改数据的时候只对数据增加行级共享锁。
```

分析

```
事务A读取某行记录时，事务B也能对这行记录进行读取、更新。
（因为事务一并未对数据增加任何锁）

当事务A对该记录进行更新时，事务B再次读取该记录，能读到事务A对该记录的修改版本。
（因为事务A只增加了共享读锁，事务B可以再增加共享读锁读取数据，即使该修改尚未被提交）

事务A更新某行记录时，事务B不能对这行记录做更新，直到事务A结束。
（因为事务A对数据增加了共享读锁，事务B不能增加排他写锁进行数据的修改）
```

# Read committed

原理

```
事务对当前被读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。
```

分析

```
事务A在读取某行记录的整个过程中，事务B都可以对该行记录进行读取。
（因为事务A对该行记录增加行级共享锁的情况下，事务B同样可以对该数据增加共享锁来读数据）

事务A读取某行的一瞬间，事务B不能修改该行数据，但是，只要事务A读取完该行数据，事务B就可以对该行数据进行修改。
（事务A在读取的一瞬间会对数据增加共享锁，任何其他事务都不能对该行数据增加排他锁。
但是事务A只要读完该行数据，就会释放行级共享锁，一旦锁释放，事务B就可以对数据增加排他锁并修改数据）

事务A更新某行记录时，事务B不能对这行记录做查询或更新，直到事务A结束。
（事务A在更新数据的时候，会对该行数据增加排他锁，直到事务结束才会释放锁，所以，在事务A没有提交之前，
事务B都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）
```

# Repeatable Read

原理

```
事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加行级共享锁，直到事务结束才释放；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。
```

分析

```
事务A在读取某行记录的整个过程中，事务B都可以对该行记录进行读取。
（因为事务A对该行记录增加行级共享锁的情况下，事务B同样可以对该数据增加共享锁来读数据。）

事务A在读取某行记录的整个过程中，事务B都不能修改该行数据。
（事务A在读取的整个过程会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，任何其他事务都不能对该行数据增加排他锁。
所以，可重复读能够解决不可重复读的读现象）

事务A更新某行记录时，事务B不能对这行记录做更新，直到事务A结束。
（事务A在更新数据的时候，会对该行数据增加排他锁，直到事务结束才会释放锁，
所以，在事务A没有提交之前，事务B都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）
```

# Serializable

原理

```
事务在读取数据时，必须先对其加表级共享锁 ，直到事务结束才释放；

事务在更新数据时，必须先对其加表级排他锁 ，直到事务结束才释放。
```

分析

```
事务A正在读取C表中的记录时，则事务B也能读取C表，但不能对C表做更新、新增、删除，直到事务A结束。
(因为事务A对表增加了表级共享锁，其他事务只能增加共享锁读取数据，不能进行其他任何操作）

事务A正在更新C表中的记录时，则事务B不能读取C表的任意记录，更不可能对C表做更新、新增、删除，直到事务A结束。
（事务A对表增加了表级排他锁，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作）
```



