---
layout: post
title: '数据一致性'
date: 2017-01-16
author: Feihang Han
tags: 微服务
---

# 本地事务

在传统的单机应用中，最简单、最直接、最普遍的会使用一个关系型数据库，通过关系型数据库的事务保证数据的一致性。这种事务有四个基本要素：ACID。

* A（Atomicity，原子性）：整个事务中的所有操作，要么全部完成，要么全部失败，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

* C（Consistency，一致性）：一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。

* I（Isolation，隔离性）：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。

* D（Durability，持久性）：在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

---

在传统的本地事务中，为了保证数据一致性，我们只需要先开始一个事务，然后进行新增、修改、删除等操作，然后提交事务，如果发生异常就回滚。简简单单，就能够站在各大数据库厂商的肩膀上，实现数据一致性。

![](/assets/doc_imgs/import.png)

# 分布式事务

随着组织规模不断扩大、业务量不断增加，单机应用已不足以支撑庞大的业务量和数据量。这个需要对应用和数据进行拆分。就出现了需要同时访问多个数据库的情况。这个时候就需要分布式事务来保证数据一致性。

两阶段提交协议（2PC，Two Phase Commitment Protocol）。在这个协议中，最关键的点就是，多个数据库的活动，均由一个事务协调器的组件来控制。具体的分为5个步骤：

![](/assets/doc_imgs/2pc_1.png)

---

在微服务架构中，数据访问变得复杂。通常情况下，数据都是各个微服务私有的，只能通过API的方式访问数据。这种方式可以实现微服务之间的松耦合，使彼此独立的微服务更容易的进行扩展。但是带来的一个问题就是，不清楚各自底层的数据存储（不一定是关系型数据库），无法通过统一的事务协调器来完成数据一致性。

简单的说，传统的本地事务或分布式事务不适合微服务架构。

# 最终一致性

在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：

* 数据一致性\(consistency\)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据，对调用者而言数据具有强一致性\(strong consistency\) \(又叫原子性atomic、线性一致性linearizableconsistency\)。

* 服务可用性\(availability\)：所有读写请求在一定时间内得到响应，可终止、不会一直等待。

* 分区容错性\(partition-tolerance\)：在网络分区的情况下，被分隔的节点仍能正常对外服务。

---

在某时刻如果满足AP，分隔的节点同时对外服务但不能相互通信，将导致状态不一致，即不能满足C；

如果满足CP，网络分区的情况下为达成C，请求只能一直等待，即不满足A；

如果要满足CA，在一定时间内要达到节点状态一致，要求不能出现网络分区，则不能满足P。

C、A、P三者最多只能满足其中两个。

对于分布式系统来说，分区容错性（P）是基本要求，否则就失去了价值。因此，就只能在可用性（A）和一致性（C）之间做出选择。

# 那么，如何做出选择呢？

假设选择一致性，那么我们需要付出在满足一致性之前阻塞其他并发访问的代价。这可能持续一个不确定的时间，尤其是在系统已经表现出高延迟时或者网络故障导致失去连接时。

依据目前的成功经验，可用性一般是更好的选择，但是在服务和数据库之间维护数据一致性是非常根本的需求，微服务架构中选择满足最终一致性。

# 可靠事件模式

可靠事件模式属于事件驱动架构，当某件重要事情发生时，例如更新一个业务实体，微服务会向消息代理发布一个事件。消息代理会向订阅事件的微服务推送事件，当订阅这些事件的微服务接收此事件时，就可以完成自己的业务，也可能会引发更多的事件发布。

以订单创建为例子：

1. 订单服务创建一个订单，发布一个“创建订单”事件。![](/assets/doc_imgs/oo1.png)

2. 支付服务消费“创建订单”事件，待支付完成后发布一个“支付成功”事件。![](/assets/doc_imgs/oo2.png)

3. 订单服务消费“支付成功”事件，订单状态更新为待出库。![](/assets/doc_imgs/oo3.png)

这个过程可能导致出现不一致的地方在于：

* 订单服务发布事件成功，缺提交事务失败。

* 虽然服务发布事件成功，但是消息代理未能正确推送事件到订阅的微服务。

* 接受事件的微服务重复消费了事件。

# 可靠消息中间件

虽然我们可以使用本地事务表来保证消息的可靠性，但是这种侵入式的设计并不是最好的。对于分布式系统而言，一个可靠的消息中间件是很重要的一个环节。

RocketMQ是一款低延迟，可靠，可扩展，易于使用的面向消息的中间件，诞生于阿里巴巴大规模消息业务。  
它提供了如下各种功能：

* 发布/订阅和P2P消息传递模型

* 可靠的FIFO和严格的顺序消息传递在同一队列中

* 长拉队列模式，也支持推消费风格

* 百万消息在单个队列中的积累能力

* 通过各种消息协议，如JMS，MQTT等。

* 分布式高可用部署架构，至少满足一次消息传递语义

* 孤立的测试和云的Docker图像孤立的集群

* 功能丰富的管理仪表板，用于配置，指标和监控云计费

* 消息全链接跟踪云计费

* 生产者事务消息，使生产者和本地数据库事务在一个原子操作Cloud Charge

* 消息计划交付，类似JMS2规范的交付延迟云计费

RocketMQ提供的各项优秀特性，正是一个分布式系统所需要的。基于RocketMQ，我们可以设计出较为优秀的分布式系统实践。

