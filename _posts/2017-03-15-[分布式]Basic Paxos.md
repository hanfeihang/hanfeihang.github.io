---
layout: post
title: 'Basic Paxos'
date: 2017-03-15
author: Feihang Han
tags: 分布式
---

# 1背景

Paxos算法由lamport大师提出，目标是解决分布式环境下数据一致性的问题。

# 2Baisc Paxos

整个Paxos算法是为了解决整个Log Sequence一致性的问题，一般也称为Multi Paxos。而Basic Paxos是为了确定一个不变量的取值，放到上面的Log Sequence一致性上来讲，即为了确定某一个log的取值，保证多个Server一旦确认该log之后，其值就不会再变化。

## 2.1问题由来

假设一组进程能提出（propose）value，分布式一致性算法能保证最终只有一个value被选择（chosen）。如果没有value被提出，那么就没有value被选择。如果一个value被选择了，那么这组进程能学习（learn）到被选择的value。

这种达成共识的过程要求满足以下的条件：

* 只能接受发出的提案
* 只能接受一个提案
* 进程在提案选择未达成共识前是不能获知选择了哪个提案

该共识算法中有三类代理角色：提案发起者\(proposer\)、接收者\(acceptor\)和学习者\(learner\)。在一个具体的实现中，单个进程可能同时兼任多种角色。

现在假设角色之间通过消息进行通信。我们使用一个常见的模型：异步的非拜占庭\(non-Byzantine\)模型。在该模型中：

* 代理角色\(agent\)处理速度各异且有可能会失败以及重启。由于在提案被选定之后所有的agent都有可能失败并重启，因此失败的agent必须要额外保存一些信息才行
* 发送消息速度也是各异，同时消息也有可能重复或丢失，但消息不能损坏

## 2.2选定提案值

一个提案发起者发送一个提案给接收者，而后者选定它接收到的第一个提案。这个方法虽然简单但却不能令人满意，因为这个接收者一旦宕机整个系统就不能用了——这就构成了一个单点失效。

因此我们要尝试另一种方案来选定提案。这次我们使用多个接收者代理，某个提案发起者发送提案给一组接收者。一个接收者可能会接收提案中的值，也可能不会。只有当足够多的接收者都接受某个提案时才认为选定了这个提案。那么现在问题来了，足够多是什么含义呢？——若要确保只能有一个提案被选定，我们使用一个足够大的集合来表示半数以上的agent。由于任意两个半数以上的agent集合必定包含至少一个共同的接收者，因此如果限制一个接收者最多只能接受一个值，那么这个方案就必定是可行的。

在消息不会失败或丢失的情况下，即使一个提案发起者只提交了一个提案我们也要选定那个提案。这就意味着以下的条件必须要满足：

**P1：一个接收者必须要接受它收到的第一个提案**

但是这个条件引出了另外一个问题：不同的提案发起者几乎同时提出不同的提案，可能造成这样的局面：即每个接收者都接受过某个提案，但却没有一个提案被半数以上的接收者都接受。即使只有两个提案，如果每个都被不同的半数接收者接受，那么只要一个接收者宕机了都会让其他接收者没法获知选定的提案。

上面提到的P1条件以及"提案只有被半数以上接收者接受才会被选定"的条件意味着一个接收者必须要能够接受多个提案。对于接收者可能会接受的提案，Paxos会给每个提案分配一个提案号\(自然数\)记录并区分不同的提案，所以一个提案其实是由一个提案号和提案中的值组成。为了避免歧义，Paxos要求每个提案都要有不同提案号。当然了，这依赖于算法的实现，但目前我们不管具体的细节。当某个提案被半数以上的接收者都接受时Paxos就会选定这个提案的值，此时我们可以说这个提案\(以及它的值\)被选定了。

Paxos允许选定多个提案，但前提是确保这些被选定的提案必须具有相同的值。基于对提案号的推导，这足以保证：

**P2：如果被选定提案的值是v，那么后续被选定的具有较高编号的提案的值必须也是v**

因为提案编号是有顺序的，条件P2就能严格地保证只能有一个提案值被选定。

如果一个提案要被选定，那么这个提案至少要被一个接收者接受。因此，Paxos通过满足以下条件来达到满足P2条件的目的：

**P2a：如果选定提案的值是v，那么接收者如果要接受后续提案则它们的值也必须是v**

Paxos仍然要维持满足条件P1以确保一定会选定某个提案。由于通信是异步的，一个提案被选定的时候可能存在某个特定的接收者c从来没有收到过任何提案。此时，如果一个新的提案发起者被唤醒并发起了一个具有更大编号但值不同的提案给c，那么根据条件P1，c就必须要接受这个提案，从而就违反了P2a的规定。此时怎么办呢？我们必须要同时满足条件P1和P2a。这就需要我们完善P2a的表述为：

**P2b：如果被选定提案的值是v，那么任何提案发起者发起的后续提案\(具有更大的提案号\)的值也必须是v**

提案总要先发出才能被接受，所以满足了P2b自然就满足了P2a，因而也就满足了P2。

下面要看一下如何才能满足P2b。假设一个提案的编号是m，值是v，我们需要证明任何后续的编号为n的提案\(n &gt; m\)的值也是v。对n使用归纳法可能会让证明变得容易。即如果证明每个编号介于\[m, n - 1\]的提案的值都是v，那么我们就能证明编号为n的提案的值也是v。若要选定编号为m的提案，必然要存在一个集合C包含了半数以上的接收者已使得C中的每个接收者接受此提案。将这个提法与归纳法结合起来看就会发现提案m被选定其实表示：

* 集合C中的每个接收者都曾接受过\[m, n - 1\]中的某个提案，并且被某个接收者接受的编号位于\[m, n - 1\]间的每个提案，其值都是v。

因为包含半数以上接收者的任何集合S都至少包含C中的一个成员，所以我们能够推断出编号n的提案的值是v，主要的依据就是：

**P2c：对于任意的v和n，如果值是v编号为n的提案被发出，那么存在一个包含了半数以上接收者的集合S，使得 **

**\(a\) S中所有接收者都没有收到过编号小于n的提案；或者**

**\(b\) 在S中接收者接受的编号小于n的所有提案内具有最大编号的提案的值是v。**

因此如果满足了P2c条件也就满足了P2b。如果要保证满足P2c，想要发出编号n提案的发起人必须要获知已经或者将要被半数以上接收者都接受提案中，哪个提案的编号最接近于n\(如果存在的话\)。发现并找出那些已经被接受的提案很容易；而预测哪些提案会被接受则困难得多。因此我们并不做任何的预测，相反，提案发起者只是想保证说不要再接受这样的提案。换句话说，提案发起者只是要求接收者不要再接受那些编号小于n的提案。okay，我们现在就可以实现发送提案的算法了，算法如下：

1. 一个提案发起者选择一个新的编号n并发送请求给某个接收者集合中的每个接收者，并希望接收者：

   \(a\). 给出一个承诺，即不再接受任何编号小于n的提案，并且

   \(b\). 提供它接受过的编号最接近n的提案\(如果存在的话\)

Paxos把这样的请求称为编号为n的prepare请求。

1. 如果该提案发起者收到了半数以上接收者发过来的响应\(response\)，那么它就能发起一个编号为n值是v的提案，其中v是所有响应中编号最大的那个提案的值。但如果响应者并没有反馈任何提案给发起者，那么发起者就可以使用任意值。

之后提案发起者发送提案请求给一组接收者，请求它们接受该提案。\(响应请求的接收者集合不要求就得是响应初始prepare请求的那组接收者。\) 我们将这个请求称为accept请求。

以上就是提案发起者的算法。那么接收者算法是怎么样的呢？它会从发起者处接收到两类请求：prepare请求和accept请求。原则上说，接收者即使丢弃这两类请求也不会破坏安全性。因此，只有它被允许去响应一个请求时我们才会显式地说明。接收者总是能够响应一个prepare请求。另外如果没有显式地被禁止，它也能够响应一个accept请求以接受收到的提案。换言之就是：

**P1a：当且仅当一个接收者没有响应过编号大于n的prepare请求时它才能接受编号为n的提案**

我们可以发现，P1a实际上包括了P1的表述。

现在我们已经可以有了一个完整的算法来选定提案值以满足那些必须条件——当然一切的前提是要假设每个提案的编号是唯一的。最终的算法只是引入了一处小小的优化。

假设一个接收者收到了一个prepare请求，编号是n，但是它之前已经响应过编号大于n的prepare请求了，也就是说它不应该再响应任何编号为n的新提案了。接收者此时也不能再响应这个新收到的prepare请求，因为它将不会再接受编号是n的提案。于是我们要让接收者忽略这样的prepare请求，同时这个接收者也要忽略那些包含它已接受提案的prepare请求。——这就是上一段中说的优化。

对算法进行这样的优化之后，一个接收者只需要记住它接受过提案的最大编号以及它响应过的prepare请求的最大编号即可。不管成功或失败，P2c都是要被满足的。基于这个原因，一个接收者就必须要记住这些信息，即使是在它失败重启之后。值得注意的是，提案发起者总是能够丢弃一个提案并删除所有与该提案相关的信息——只要它从没尝试发起编号相同的另一个提案。

把提案发起者与接收者的行为结合在一起，我们可以看出Paxos算法的执行分为以下两个阶段：

**阶段1**

\(a\) 提案发起者选择提案编号n并使用该编号发送一个prepare请求给半数以上的接收者

\(b\) 如果有接收者收到了编号n的该prepare请求且它之前响应过的所有prepare请求中的编号都**小于等于**n，那么接收者将响应该请求并保证以后再也不会接受编号**小于**n的任何提案并且会返回它接受过的具有最大编号的提案\(如果存在的话\)。

**阶段2**

\(a\) 如果提案发起者从半数以上的接收者处收到了它发出的prepare请求\(编号是n\)的响应，那么它就会发送一个accept请求给对应的每个接收者请求编号是n值是v的提案被接受。其中v是所有响应包含的提案中最大编号的那个提案的值或者是一个任意值如果反馈的响应中压根就不包含任何提案的话。

\(b\) 当接收者收到一个包含编号n提案的accept请求后，它会进行判断：如果它之前已经响应过编号大于n的prepare请求了，那么它就不会接受该提案；否则它一定要接受该提案。

只有遵循上述算法中的步骤，一个提案发起者是可以发起多个提案的。在整个过程中间它也可以在任意时候丢弃提案。\(当然了还是要保证正确性，即使提案被丢弃很长时间之后请求和响应才各自被接收者和发起者收到。\) 如果某个发起者已经开始尝试去发送一个更高编号的提案了，那么此时丢弃那个较小编号的提案似乎是个不错的选择。因此，如果一个接收者由于已经收到了更高编号的prepare请求而将某个prepare请求或accept请求忽略的话，那么该接收者也应该通知对应的提案发起者，让它也丢弃它的提案。这样做既不破坏正确性还又优化了算法的性能。

伪代码如下：

```c
Proposer_Send_Prepare()
{
    select a proposal id n;
    send a prepare request with id n to a majority of acceptors
}

Acceptor_Response_Prepare()
{
    if receive prepare request id with n > max_prepared_id recoreded {
        send(not accept proposal numbered less than n);
        send(highest-numbered proposal it has accepted if exist)
        max_prepared_id = id
    } else {
        do nothing;
    }
}

Proposer_Send_Accept()
{
    if get responce from majority {
        send proposal(n, v); // v is the hightest-numbered proposal's value from reponses, or if any value if the responsed reported no proposals
    } else {
        abort()
    }
}

Acceptor_Response_Accept()
{
    if max_prepared_id == request_accept_id {
        accept the proposal
    } else {
        do nothing
    }
}
```

## **2.3 学习被选定的提案值\(learning a chosen value\)**

最简单粗暴的方案是，每当一个acceptor接受了新的proposal的时候，就广播给所有的learner，假设acceptor的数量为m，learner的数量为n，那么需要O\(m\*n\)通信的开销。

为了减少通信开销，可以选出一个learner，负责接收acceptor的消息，然后再由它通知给其他的learner，这时需要O\(m+n\)。这个方法的缺点是如果这个learner宕机了，整个系统就无法正常工作了。改进的方案是，选择一组learner，假设数量为c，负责接受acceptor的消息，这些leaner负责通知其他的leaner，该方案的通信开销为c\*o\(m+n\)，且可用性比较高，只要c个learner中没有全部宕机，系统就可以正常工作。

## **2.4 进度**

我们可以很容易地构建这样的一个场景：两个发起者进程各自不断地发起编号递增的一组提案，但没有一个提案胜出。发起者p完成了编号n1的提案的阶段1，而另一个发起者q也完成了编号n2&gt;n1提案的阶段1。此时发起者p的阶段2中的编号n1的accept请求就会被忽略掉，因为接收者要确保不再接受任何编号小于n2的提案。于是，发起者p使用编号n3&gt;n2开启并完成了新的阶段1，导致发起者q的第二个阶段的accept请求也被忽略掉了。因此这种"悲剧"会不断地继续下去，整个共识算法不会有任何进展。

为了应对这种情况，Paxos选择一个特殊的发起者，规定只能由它来发送提案。如果该发起者能够成功地与半数以上的接收者通信且它使用的提案号比已使用的都要大的话，那么它发出的提案就会被选定。如果使用的提案号比某个请求的编号要小，该发起者会放弃较小编号的提案并不断重试直到最终它选择了一个足够大的提案号。

如果系统大部分组件\(发起者，接收者和网络\)工作正常的话，使用这种单个特定发起者的方案是能够避免liveness问题\(Liveness问题大概可以理解为因为某些原因，比如死锁或饥饿等使得系统没法向前推进\)的。很多论文提出选择一个发起者的可靠算法都必须要使用随机或实时来完成——比如使用超时。但不管怎么样，无论选举成功还是失败，安全性都是要首先保证的。

## **2.5 实现**

Paxos算法涉及了一组进程网络。在它的共识算法中，每个进程都同时扮演了提案发起者、接收者和学习者的角色。算法首先会选取一个领导者进程来充当特定发起者和统一学习者的角色。Paxos共识算法就是我们上面描述的算法——在该算法中，提案的请求与响应都是作为普通的消息被发送与传递。\(响应消息将打上对应的提案号标签以关联对应的请求并阻止歧义。\) 实现时要使用持久化存储来保存接收者必须要记住的信息以应对接收者的失败。接收者在发送响应之前也会在持久化设备中保存它们。

下面就该说说如何确保不会发出编号相同的多个提案。不同的发起者进程需要从不相交的编号集合中选择提案号，这样两个不同的发起者进程永远不会发出相同编号的提案。每个发起者将它发送过的最大编号的提案保存在持久化设备中，然后使用一个更大的编号开启算法的阶段1。

# 参考

[https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/paxos-simple-Copy.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/paxos-simple-Copy.pdf)

[http://oserror.com/distributed/paxos-principle-first/?utm\_source=tuicool&utm\_medium=referral](http://oserror.com/distributed/paxos-principle-first/?utm_source=tuicool&utm_medium=referral)

