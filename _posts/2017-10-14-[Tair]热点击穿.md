---
layout: post
title: 'Tair热点击穿'
date: 2017-10-14
author: Feihang Han
tags: Tair 缓存
---

Tair是一款专注于高性能、分布式、可扩展、高可靠的 NoSQL 存储产品，提供了分布式缓存方案，在整个公司内部有着广泛的应用。  
目前支持MDB，RDB和LDB三款产品，可适用于各种常见的存储场景。  
其中MDB属于内存型产品，支持KV和类hashmap结构，性能最优，但不支持持久化存储；  
RDB支持List，Set，Zset等复杂的数据结构，性能次之，可提供缓存和持久化存储两种模式；  
LDB属于持久化产品，支持KV和类hashmap结构，性能较前两者稍低，但持久化可靠性最高。

# 热点击穿

事件回放：xx时交易下跌20%出现高级故障。分析原因为突发热点流量，被tair限流，应用访问缓存失败后访问db，最终db超过阈值无法提供服务而产生故障。

1、对于这样突发的超过预期的流量怎么办，远远超过tair申请时评估的qps，当然被限流。  
2、qps在预期范围内，但qps太高，评估下来tair集群的成本过高。

对于上面2个问题，现在tair有了HotKey解决方法。

# HotKey解决方案

支持 Hotkey 的 Tair 服务端版本会在运行时统计维护当前的 Hotkey 状态，当客户端访问到 Hotkey 时，热点通知的 feedback 包会随着客户端的 get 类的请求一并返回。客户端对热点 key 的识别依据服务端热点反馈的 feedback 包。

1. 收到服务端反馈的 Hotkey 后， 客户端依赖自身的 Localcache 功能，每次写操作会自动强制删除 Localcache 里存在的 key，读操作后会自动从 Localcache 里读取， Localcache 中不存在则从服务端获取，成功后存储到 Localcache 里。在 Hotkey 防御系统中，客户端要开启 hot-running 模式，该模式下只能缓存带热点标记的 key，Localcache 中非热点的 key 将逐步被淘汰。即一旦开启客户端的该模式，会强制改变 Localcache 的工作模式。
2. 服务端的 Hotkey 功能只对读热点进行采样分析（写操作必须请求到服务端），具体的规则如下：
   * get、prefixGet、getHidden、prefixGetHidden 这类接口的key是普通单 key 或 mixed-key，在服务器端 Hotkey 逻辑看来，跟普通单 key 没有区别。直接取出 key 或 mixed-key 做统计。
   * prefixGets、prefixGetHiddens、simplePrefixgets（当前只有一个pkey）这类接口是一个 pkey 下面包含多个 skey 的。服务器端统计时只取其 pkey 部分，pkey 的命中次数以 skey 的个数作为权值。如果该 pkey 成为热点，服务器会通过 feedback 控制客户端缓存该pkey下所有skey。
   * mprefixGets、mprefixGethiddens 这类接口是有多个 pkey，并且每个pkey 下面有多个 skey。但是到达服务端还是多个请求分开的，服务器端会把每个 pkey 都统计一遍，只返回其中热点的pkey。
   * mGet 这类请求会一次性带多个 key，服务端会迭代统计该请求上每个 key，并只返回其中热点部分。

# 开启方法

```
MultiClusterTairManager mcTairManager = new MultiClusterTairManager();
mcTairManager.setConfigID("xxxxx");// 或者使用username初始化 mcTairManager.setUserName("xxxxx");
mcTairManager.setDynamicConfig(true);
// 向服务端注册热点key反馈功能
mcTairManager.setNeedRegisterClientVersion(true);   

mcTairManager.init();

// 该行开启客户端原生 Localcache
// namespace 1, 最多缓存2000个key，本地缓存过期时间1000ms
mcTairManager.setupLocalCache(1, 2000, 1000);

// 该行启用 namespace 1 的 hot-running 工作模式
mcTairManager.enableLocalCacheImprove(1);
```



