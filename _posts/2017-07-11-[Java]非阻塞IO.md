---
layout: post
title: 'Java非阻塞IO'
date: 2017-07-11
author: Feihang Han
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: JAVA
---

从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两码事。操作系统内核对I/O只有两种方式：阻塞与非阻塞。

#### 阻塞I/O

在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。以读取磁盘上一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。

阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力得不到充分利用。

#### 非阻塞I/O

为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回。

非阻塞I/O返回之后，CPU的时间片可以用来处理其他事物，此时的性能提升是明显的。但非阻塞I/O也出在一些问题。由于完整的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做**轮询**。

#### 轮询

阻塞I/O造成CPU等待浪费，非阻塞I/O带来的麻烦却是需要轮询去确认是否完全完成数据的获取，它让CPU处理状态判断，是对CPU资源的浪费。以下是轮询技术的演进过程。

现存的轮询技术主要有以下几种。

1. read - 它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗在等待上。
2. select - 它是在read的基础上改进的一种方案，通过文件描述符上的事件状态来进行。select轮询具有一个较弱的限制，由于它采用一个1024长度的数据来存储状态，所以它最多可以同时检查1024个文件描述符。
3. poll - 该方案较select有所改进，采用链表的方式避免数据长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。
4. epoll - 该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候，如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。
5. kqueue - 该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。

#### 理想的异步I/O

尽管epoll已经利用了事件来降低CPU的耗用，但是休眠期间CPU几乎是闲置的，对于当前线程而言利用率不够。那么，是否有一种理想的异步I/O？

我们期望的完美的异步I/O应该是应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或者回调，将数据传递给应用程序即可。

幸运的是，在Linux下存在这样一种方式，它原生提供一种异步I/O方式（AIO）就是通过信号或回调来传递数据。

但不幸的是，只有Linux下有，而且它还有缺陷——AIO仅支持内核I/O中的O\_DIRECT方式读取，导致无法利用系统缓存。

#### 现实的异步I/O

现实比理想要骨感一些。前面我们将场景限定在了单线程的状况下，多线程的方式会是另一番风景。通过让部分线程进行阻塞I/O或非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O（尽管它是模拟的）。

> glibc的AIO便是典型的线程池模拟异步I/O。然而遗憾的是，它有一些难以忍受的缺陷与bug，不推荐使用。
>
> libeio实质上依然是采用线程池与阻塞I/O模拟异步I/O。
>
> 另一种的异步I/O方案是windows下的IOCP，它在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无需考虑轮询。但是它的内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。



