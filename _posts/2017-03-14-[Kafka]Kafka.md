---
layout: post
title: 'Kafka简介'
date: 2017-03-14
author: Feihang Han
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: Kafka
---

#### 简介

Apache Kafka是一个分布式流平台。一个分布式流平台有以下特点：

1. 它可以发布订阅记录流。类似于消息队列或者企业消息总线。
2. 它以容错的方法存储记录流。
3. 它可以让你实时处理记录流。

它被应用于两大类应用系统：

1. 打造从系统或应用中获取数据的实时流数据管道。
2. 打造实时流应用，用于转换或响应流数据。

Kafka有以下特性：

* Kafka以集群的形式运行。
* Kafka以主题的形式存储记录流。
* 每一个记录由key、value和时间戳组成。

Kafka有以下四个核心APIs：

* Producer API：向多个主题发布记录流。
* Consumer API：订阅一个或多个主题，并处理记录流。
* Streams API：从一个或多个主题消费输入流，转化数据流，然后向一个或多个主题生产输出流。
* Connector API：打造可重用的生产者和消费者。

![](http://kafka.apache.org/0102/images/kafka-apis.png)Kafka在客户端和服务端之间的通信是通过一个简单的、高性能的、语言无关的TCP协议。该协议是版本化，且保持兼容旧版本。

#### Topics and Logs

主题是记录的分类，往往被多个消费者订阅。

对每个主题而言，kafka集群维护了一个分区日志如下：

![](http://kafka.apache.org/0102/images/log_anatomy.png)

每个分区是一个有序的，不可改变的记录序列，新的日志被追加到一个结构化的提交日志后。在分区中的每个记录有一个唯一序列号offset。

kafka集群保留所有被发布的记录一定时间，不管是否被消费，该时间是一个可以配置的参数。对于不同的数据大小而言，kafka的性能是相对稳定的，所以存储数据很长一段时间不是一个问题。

![](http://kafka.apache.org/0102/images/log_consumer.png)事实上，只有唯一的元数据——每个消费者的offset被保存了。offset被消费者控制：正常情况下，消费者随着消费记录，线性增加offset；但事实上，消费者可以随意控制offset进行消费。

分区是有几个目的。第一，允许日志进行伸缩；每个独立的分区必须适合承载它的服务器，所以一个主题可以有很多分区，这样它就能处理任意多的数据。第二，它们作为平行的单元。

#### 分布

Kafka集群中的日志，以分区的形式分布，每个服务器处理数据和请求。每个分区跨服务器进行容错备份，基于一个可配置的数量。

每个分区有一个leader，零个或多个followers。leader处理所有的读写请求，follower被动的复制leader。如果leader失败了，那么其中一个follower将会自动的成为新的leader。每个服务既是某些分区的leader，同时也是另外一些分区的follower，这样读写请求的压力可以平摊给整个集群。

#### 生产者

生产者向主题分发数据，并且可以指定某个分区。这既可以是轮询，也可以是根据某个规则，比如基于某个key。

#### 消费者

每个消费者有一个组。在一个消费者组内，消息是负载均衡的。而跨消费者组时，消息是广播的。极端情况下，

如果所有消费者在一个组内，那么记录会在这个组内的消费者之间进行负载均衡。

如果所有消费者都在一个独立的组内，那么消息会广播给所有消费者。

![](http://kafka.apache.org/0102/images/consumer-groups.png)

消费者组可以认为是“逻辑”订阅者，由很多消费者实例组成，便于伸缩和容错。这就是发布订阅模型，其中订阅者是一个消费者组而不是单一线程。

Kafka中实现的消费方式是将日志中的分区分配给不同的消费者实例，以便每个实例在任何时间点都是“公平共享”分区的独占用户。Kafka动态的处理并维护关系。当一个新的消费者实例加入一个组的时候，它会接管一些分区的消费任务；当一个实例宕机的时候，则它负责的分区会被分配给其他还活着的实例。

Kafka只会保证一个主题下的一个分区内的记录是有序的，而不是跨分区。对于大多数应用而言，每个分区的有序性结合根据key对数据进行分区是足够了的。然而，如果你需要一个全局的有序记录，这可以通过一个只有一个分区的主题来实现，这也意味着每个消费者组只有一个消费者可以进行消费。

#### 保证

高等级Kafka给出如下保证：

* 发往一个主题的一个分区的消息是保序的，且与发送顺序一致。 
* 消费者按记录被存储的顺序进行消费。
* 对于一个有N个分区的主题，我们可以最多容忍N-1个服务端失败，而不丢失任何提交的记录。

#### 参考

[http://kafka.apache.org/documentation/](http://kafka.apache.org/documentation/)

